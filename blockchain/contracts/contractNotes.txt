SOLIDITY DESIGN PRINCIPLES
- Can use a "factory" contract whose main functionality is to create new objects, or structs, of a certain type, as well
  as store an array or mapping to keep track of all those new objects.
  A new struct can be created by simply calling: Struct("params"), similar to how new objects are created in OOP,
  however, no "new" keyword is necessary.
  This is a differing point from OOP. A contract is not analogous to a class. A constructor for a contract creates
  a new copy of the contract everytime it is called, which can be costly.
  It seems that an OOP "object" is more similar to a "struct" in solidity

- Solidity supports inheritance, so a contract inheriting from another contract has access to all public functions
  in the contract it is inheriting from.
- Inheritance can be used logically, with subclasses. However, a differing point from OOP is that inheritance can also
  simply be used for organizing code by grouping similar logic together in different contracts.

- When creating a factory for a struct, you may want to use two data structures.
    1. An array of structs - to simply store all the structs
    2. A mapping - perhaps of the struct id to struct owner address
  Alternatively, you could just create a mapping of the struct owner address to the struct, since addresses are unique
  identifiers.
  However, if your struct has mappings, this creates a nested mapping, which means your mapping cannot be public, which
  means you cannot access this mapping outside of your contract, which makes things difficult.

- You can use built-in time units to implement calling of certain functions at certain times. For example, using the "now"
keyword to get the current UNIX timestamp.

- Pass a storage pointer to a struct in a PRIVATE or INTERNAL function, which allows us to reference a struct instead of
having to pass in an ID and look it up (more efficient)

- Examine external and public functions to see if they can be abused by users, and maybe change it to internal or private 
if it can be called by another function in contract

